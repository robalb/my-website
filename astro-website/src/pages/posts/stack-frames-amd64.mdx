---
layout: '../../layouts/BlogPost.astro'
title: moving data - a visual guide to amd64 assemly
publishDate: 2024-02-18
description: 
tags: ['amd64']
permalink: https://halb.it/posts/the-story-of-the-frog-puzzle/
---
import Picture from '../../components/Picture.astro'
import SliderHexdump from '../../components/SliderHexdump.svelte'
import PtrHexdump from '../../components/PtrHexdump.svelte'
import Registers from '../../components/Registers.svelte'

It's common knowledge that assembly language is complex.
After all there must be a reason why
we have compilers that write it for us, and high-level languages with a completely 
different syntax, designed to be understandable by humans.

But while it's true that you would have a hard time writing a large, complex project
in assembly, the language itself is the simpliest you will ever learn:
Assembly is the language of the processor, and at it's core, all the processor does is moving data.

This guide is not about writing assembly, it's about understanding the way memory moves
behind the scenes when you execute a program. We'll use concrete examples for the
amd64 architecture, but these informations apply eveywhere, and are foundamental knowledge 
for reverse engineering, binary exploitation, or simply program debugging

### what is data?

Data is just bites, representing information. It can be in only 2 places:
- in memory, which means in your RAM
- in registers, which are special containers inside your CPU

### memory

Memory is just a very long list of
contiguos cells, each containing 8 bits of information, and reachable by a numeric address.

Since printing a long list of bytes would take a lot of space,
when visualizing memory we usually group bytes in rows of 8 or 16.
You can adjust the slider below to try different visualizations of an example memory dump:

<SliderHexdump
  client:load 
  showAscii={false}
  data={[
  80, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 81, 85, 85, 85, 85, 0, 0, 64, 220, 255, 255, 1, 0, 0, 0, 88, 220, 255, 255, 255, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 4, 190, 18, 120, 233, 111, 224, 88, 220, 255, 255, 255, 127, 0, 0, 233, 81, 85, 85, 85, 85, 0, 0, 152, 125, 85, 85, 85, 85, 0, 0, 64, 208, 255, 247, 255, 127, 0, 0, 232, 4, 28, 164, 135, 22, 144, 31,
  232, 4, 52, 40, 253, 6, 144, 31, 0, 0, 0, 0, 255, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 158, 135, 93, 202, 47, 126, 0, 0, 0, 0, 0, 0, 0, 0, 64, 158, 194, 247, 255, 127, 0, 0, 104, 220, 255, 255, 255, 127, 0, 0, 152, 125, 85, 85, 85, 85, 0, 0, 224, 226, 255, 247, 255, 127, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 85, 85, 85, 85, 0, 0 
  ]}
  sliderStart={0} />

### registers

Registers are containers for data, located inside your CPU.
The amd64 architecture has
[a lot of registers](https://en.wikipedia.org/wiki/X86#/media/File:Table_of_x86_Registers_svg.svg),
each with an associated name.
Some of them have a specific purpose, other are generic containers we can use in our program.
We mostly interact with these ones, that contain 64-bit values:
<Registers />

<br/>

It's also possible to access the lower portion of most registers:
Given a register name, the prefix `r` gives you access to the full 64 bit register, and the prefix `e`
 gives you access to the lower 32 bits of the same register. For example, these are all the ways you can
  access lower portions of `rax`:
<Registers display={"rax"} expand={"rax"} />

<br/>

### moving data

The instruction `mov` moves data around. It can move data from a register to another,
from a register to memory, or vice-versa from memory to a register

 These first examples are self-explanatory:

```c
mov rbx, 0x10  #copies an integer into rbx
mov rax, rbx   #copies the content of rbx into rax
```

Moving data to memory requires some extra syntax:<br/>
Let's say that our goal is to write `0xff` in the memory cell at address `0x10`.
- First, we put in a register `0x10`, the address to the cell we want to write.
- Then we perform a mov instruction with square brackets around the register name, to indicate that we want to move `0xff` in
the memory address contained in the register, and not into the register itself.

```c
mov rax, 0x10
mov byte ptr [rax], 0xff
```

What if we wanted to write to memory more than one byte, for example the whole 8 bytes contained in `rbx`?
This requires a variation of the `ptr` syntax, to specify that we want to write a sequence of 8 bytes to memory.

The interactive example below shows all the possible variations of the `ptr` syntax.
You can click "run" to see how the memory is affected

<PtrHexdump
  client:load 
  showAscii={false}
  sliderStart={0} />

### stack frames

amd64, like most architectures, has the concept of stack: an area in memory pointed
by the special register `rsp`

Some instructions, such as `push`, `pop`, `return`, and `call` read and write the memory pointed by `rsp`
